<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포켓몬 도감</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            background-color: #2c3e50;
            color: #ecf0f1;
            width: 250px;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            position: fixed;
            height: 100%;
            overflow-y: auto;
            z-index: 500;
        }
        .sidebar h2 {
            font-size: 1.8em;
            margin-bottom: 30px;
            color: #3498db;
            text-align: center;
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
        }
        .sidebar ul li {
            margin-bottom: 10px;
        }
        .sidebar ul li a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 10px 15px;
            display: block;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .sidebar ul li a:hover, .sidebar ul li a.active {
            background-color: #34495e;
            color: #ffffff;
        }
        .main-content-wrapper {
            margin-left: 250px;
            flex-grow: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        /* AdSense 광고 컨테이너 */
        .ads-container {
            width: 100%;
            min-height: 90px;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }

        .content-area {
            flex-grow: 1;
            display: flex; /* PC에서 컬럼 분할을 위한 flex */
            gap: 20px;
        }
        .content-section {
            display: none; /* JS로 제어 */
            flex-direction: column;
            flex-grow: 1;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            min-height: 600px;
            overflow-y: auto;
        }
        .content-section.active {
            display: flex;
        }

        .main-list-column, .main-detail-column {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #eee;
            min-height: 400px;
            overflow-y: auto;
            flex-shrink: 0;
            display: none; /* Default hidden, controlled by JS */
        }
        .main-list-column {
            width: 35%; /* PC: 목록 컬럼 너비 */
        }
        .main-detail-column {
            width: 65%; /* PC: 상세 컬럼 너비 */
        }
        
        /* PC에서 초기 공란 화면일 때 (main-detail-column만 보임, 확장됨) */
        #initial-blank-section.active + #dynamic-content-section {
            display: flex; /* 활성화시키지만 */
            flex-grow: 1;
            padding: 0; /* 패딩 제거 */
            box-shadow: none; /* 그림자 제거 */
            background-color: transparent; /* 배경 제거 */
        }
        #initial-blank-section.active + #dynamic-content-section .level-column-wrapper {
            flex-grow: 1;
        }
        #initial-blank-section.active + #dynamic-content-section .main-detail-column {
            width: 100%; /* 초기 공란 화면에서는 상세 컬럼이 전체 공간 차지 */
            display: block;
            background-color: #fff; /* 다시 배경 추가 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* 그림자 추가 */
            padding: 20px; /* 패딩 추가 */
        }
        #initial-blank-section.active + #dynamic-content-section .main-list-column,
        #initial-blank-section.active + #dynamic-content-section #section-title {
            display: none !important; /* 초기 공란 화면에서는 목록 컬럼과 섹션 제목 숨김 */
        }

        /* PC에서 Lev.1 클릭 후 Lev.2 목록 + Lev.3/4 상세 (3분할) */
        /* dynamic-content-section이 active이고 final-detail-view가 아닐 때 */
        .content-section.active:not(.final-detail-view) .main-list-column,
        .content-section.active:not(.final-detail-view) .main-detail-column {
            display: block; /* JS로 제어 */
        }

        /* PC에서 최종 상세 화면 (Lev.3 또는 Lev.4) 진입 시: main-list-column 숨기고 main-detail-column 확장 */
        .content-section.active.final-detail-view .main-list-column {
            display: none !important; /* Lev.2 목록 숨김 */
        }
        .content-section.active.final-detail-view .main-detail-column {
            width: 100%; /* 상세 컬럼 확장 */
            display: block !important;
        }


        .main-list-column h3, .main-detail-column h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .main-list-column ul {
            list-style: none;
            padding: 0;
        }
        .main-list-column ul li {
            margin-bottom: 8px;
        }
        .main-list-column ul li a {
            display: block;
            padding: 8px 10px;
            background-color: #ecf0f1;
            border-radius: 4px;
            text-decoration: none;
            color: #333;
            transition: background-color 0.2s ease;
        }
        .main-list-column ul li a:hover, .main-list-column ul li a.active {
            background-color: #3498db;
            color: #fff;
        }

        .detail-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: 100%;
        }
        .detail-content h4 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .detail-content img {
            max-width: 150px;
            height: auto;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .detail-content p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        .detail-content strong {
            color: #3498db;
        }
        .detail-content .back-button {
            margin-top: 20px;
            float: right;
            display: block; /* PC에서도 최종 화면에서 항상 표시 */
        }
        .pokemon-detail-card {
            background-color: #f0f2f5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
        }
        .pokemon-detail-card strong {
            color: #2c3e50;
        }
        .pokemon-detail-card .clickable-item {
            color: #3498db;
            cursor: pointer;
            text-decoration: underline;
        }
        .pokemon-detail-card .clickable-item:hover {
            color: #2980b9;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 25px;
            border: 1px solid #888;
            width: 90%;
            max-width: 600px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative;
        }
        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
        }
        .modal-body img {
            max-width: 120px;
            height: auto;
            display: block;
            margin: 0 auto 15px auto;
            border-radius: 8px;
        }
        .modal-body h4 {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #2c3e50;
            text-align: center;
        }
        .modal-body p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        /* Mobile Responsive Adjustments */
        @media (max-width: 1024px) {
            body {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                box-shadow: none;
                padding: 10px;
            }
            .sidebar ul {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            .sidebar ul li {
                margin: 5px;
            }
            .main-content-wrapper {
                margin-left: 0;
                padding: 15px;
            }
            .content-area {
                flex-direction: column;
                gap: 0;
            }
            .content-section {
                padding: 15px;
                height: auto;
                width: 100%;
            }
            .main-list-column, .main-detail-column {
                width: 100%;
                min-height: auto;
            }
            /* 모바일에서만 작동하는 표시/숨김 */
            .main-list-column.mobile-hidden { display: none !important; }
            .main-detail-column.mobile-hidden { display: none !important; }
            .main-list-column.mobile-active { display: block !important; }
            .main-detail-column.mobile-active { display: block !important; }

            .detail-content .back-button {
                display: block; /* 모바일에서 돌아가기 버튼 항상 보임 */
            }

            /* 초기 공란 화면 모바일 */
            #initial-blank-section.active + #dynamic-content-section #section-title {
                display: block !important; /* 모바일 초기 화면에도 제목을 표시하려면 */
            }
        }
    </style>
</head>
<body>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2125965839205311" crossorigin="anonymous"></script>

    <div class="sidebar">
        <h2>포켓몬 도감</h2>
        <ul>
            <li><a href="#" onclick="showSection('pokemon-type', this)" class="active">포켓몬 타입</a></li>
            <li><a href="#" onclick="showSection('pokemon-grade', this)">포켓몬 등급</a></li>
            <li><a href="#" onclick="showSection('item', this)">아이템</a></li>
            <li><a href="#" onclick="showSection('rune', this)">룬</a></li>
            <li><a href="#" onclick="showSection('chip', this)">칩</a></li>
            <li><a href="#" onclick="showSection('recommended-decks', this)">추천 덱</a></li>
            <li><a href="#" onclick="showSection('calendar', this)">캘린더</a></li>
            <li><a href="#" onclick="showSection('tips-knowhow', this)">팁 & 노하우</a></li>
        </ul>
    </div>

    <div class="main-content-wrapper">
        <div class="ads-container" id="top-ad-container">
            <ins class="adsbygoogle"
                 style="display:block; text-align:center;"
                 data-ad-client="ca-pub-2125965839205311"
                 data-ad-slot="5532734526"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
        </div>

        <div class="content-area">
            <div id="initial-blank-section" class="content-section active">
                <h1 class="text-3xl font-bold mb-4">환영합니다!</h1>
                <p>좌측 메뉴에서 원하는 정보를 선택해주세요.</p>
            </div>

            <div id="dynamic-content-section" class="content-section">
                <h1 id="section-title" class="text-3xl font-bold mb-4"></h1>

                <div class="level-column-wrapper">
                    <div class="main-list-column" id="main-list-column">
                        </div>
                    <div class="main-detail-column" id="main-detail-column">
                        </div>
                </div>
            </div>
        </div>
    </div>

    <div id="generalModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('generalModal')">&times;</span>
            <div class="modal-header">
                <h3 id="generalModalTitle" class="text-2xl font-bold mb-4"></h3>
            </div>
            <div class="modal-body" id="generalModalBody">
                <img id="generalModalImage" src="" alt="이미지" class="hidden">
                <p id="generalModalDescription"></p>
            </div>
        </div>
    </div>

    <script src="data.js"></script>
    <script>
        // 전역 변수들
        let currentActiveSectionType = 'initial'; // 현재 활성화된 섹션의 타입 (예: 'pokemon-type', 'item')
        let currentDisplayLevel = 'initial'; // 현재 main-detail-column에 표시되는 내용의 레벨: 'initial', 'level3', 'level4'
        let navigationStack = []; // 뒤로가기 관리를 위한 스택 ( {type, level, filterValue, pokemonId} )

        const mediaQuery = window.matchMedia('(max-width: 1024px)');
        const adClient = "ca-pub-2125965839205311";
        const adSlot = "5532734526";

        // DOM 요소 캐싱 (자주 사용되는 요소)
        const mainListColumn = document.getElementById('main-list-column');
        const mainDetailColumn = document.getElementById('main-detail-column');
        const dynamicContentSection = document.getElementById('dynamic-content-section');
        const initialBlankSection = document.getElementById('initial-blank-section');
        const sectionTitleElement = document.getElementById('section-title');

        // --- 핵심 로직: 섹션 전환 및 콘텐츠 렌더링 ---

        // Lev.1 카테고리 클릭 시 호출
        function showSection(sectionType, clickedElement) {
            // 모든 섹션 숨기기 및 초기 상태 정리
            initialBlankSection.classList.remove('active');
            dynamicContentSection.classList.add('active');

            sectionTitleElement.textContent = getSectionTitle(sectionType); // 섹션 제목 설정

            // 사이드바 링크 활성화 스타일 변경
            document.querySelectorAll('.sidebar ul li a').forEach(link => {
                link.classList.remove('active');
            });
            clickedElement.classList.add('active');

            currentActiveSectionType = sectionType; // 현재 활성 섹션 타입 업데이트
            navigationStack = []; // 새 섹션 시작 시 스택 초기화

            // 초기 로드: 항상 Lev.2 목록부터 시작
            // showContentColumns 함수가 PC/모바일 분할과 스택 푸시를 담당합니다.
            // 첫 번째 상태는 항상 Lev.2 목록이므로, options에 type만 넘깁니다.
            showContentColumns('list', { type: sectionType, isInitial: true });

            // 각 섹션에 맞는 초기 목록 렌더링 (mainListColumn에)
            if (sectionType === 'pokemon-type') {
                renderPokemonTypeOrGradeList('pokemon-type');
            } else if (sectionType === 'pokemon-grade') {
                renderPokemonTypeOrGradeList('pokemon-grade');
            } else if (sectionType === 'item') {
                renderGenericList('item', window.itemDetails);
            } else if (sectionType === 'rune') {
                renderGenericList('rune', window.runeDetails);
            } else if (sectionType === 'chip') {
                renderGenericList('chip', window.chipDetails);
            } else if (sectionType === 'recommended-decks') {
                renderRecommendedDeckTypeList();
            } else if (sectionType === 'calendar') {
                renderCalendarTypeList();
            } else if (sectionType === 'tips-knowhow') {
                renderTipsAndKnowhowList();
            }

            showAd(); // 광고 새로고침
        }

        // --- 컬럼 표시 관리 헬퍼 함수 ---
        // levelState: 'list' (Lev.2 목록), 'pokemon-names' (Lev.3 포켓몬 이름 목록), 'detail' (Lev.3 일반 상세), 'pokemon-final-detail' (Lev.4 포켓몬 최종 상세)
        // options: {type, filterValue, pokemonId, isInitial} - 현재 화면의 컨텍스트를 저장. isInitial은 초기 로드인지 여부
        function showContentColumns(levelState, options = {}) {
            // 스택에 현재 상태 푸시 (중복 방지)
            const currentState = {
                level: levelState,
                type: options.type || currentActiveSectionType, // type이 없으면 현재 활성 섹션 타입 사용
                filterValue: options.filterValue,
                pokemonId: options.pokemonId
            };

            // 초기 로드 시 navigationStack을 재설정하지 않기 위해 isInitial 플래그 추가
            // (isInitial은 showSection에서 첫 showContentColumns 호출 시만 true)
            if (!options.isInitial || navigationStack.length === 0) {
                 const lastState = navigationStack[navigationStack.length - 1];
                 if (!lastState || JSON.stringify(lastState) !== JSON.stringify(currentState)) {
                     navigationStack.push(currentState);
                 }
            }
            
            currentDisplayLevel = levelState; // 현재 상세 컬럼에 표시되는 레벨을 업데이트

            // PC와 모바일 화면 전환 로직
            if (mediaQuery.matches) { // 모바일 환경 (단일 화면)
                if (levelState === 'list') { // Lev.2 목록만 활성화
                    mainListColumn.classList.remove('mobile-hidden');
                    mainListColumn.classList.add('mobile-active');
                    mainDetailColumn.classList.remove('mobile-active');
                    mainDetailColumn.classList.add('mobile-hidden');
                } else { // Lev.3 또는 Lev.4 상세만 활성화
                    mainListColumn.classList.remove('mobile-active');
                    mainListColumn.classList.add('mobile-hidden');
                    mainDetailColumn.classList.remove('mobile-hidden');
                    mainDetailColumn.classList.add('mobile-active');
                }
            } else { // PC 환경 (Lev.1 + 최종 2분할)
                // 기본적으로 두 컬럼 모두 표시 (35% / 65%)
                mainListColumn.style.display = 'block';
                mainListColumn.classList.remove('collapsed'); // 혹시 모를 collapsed 제거
                mainDetailColumn.style.display = 'block';
                mainDetailColumn.classList.remove('expanded'); // 혹시 모를 expanded 제거

                // dynamicContentSection에 final-detail-view 클래스 제거
                dynamicContentSection.classList.remove('final-detail-view');

                // 최종 상세 화면 (Lev.3 상세 또는 Lev.4 상세)인 경우: PC 2분할 (Lev.1 + 최종)
                if (levelState === 'detail' || levelState === 'pokemon-final-detail') {
                    mainListColumn.classList.add('collapsed'); // Lev.2 목록 숨김
                    mainDetailColumn.classList.add('expanded'); // 상세 컬럼 확장
                    dynamicContentSection.classList.add('final-detail-view'); // 최종 상세 뷰 클래스 추가
                }
                // 포켓몬 섹션에서 Lev.3 (포켓몬 이름 목록)인 경우: PC 3분할 (Lev.1 + Lev.2 + Lev.3)
                else if (levelState === 'pokemon-names') {
                    // main-list-column (Lev.2)과 main-detail-column (Lev.3 포켓몬 이름 목록) 모두 보임
                    // width는 CSS 기본값 (35%, 65%) 유지
                }
                // 그 외 (초기 Lev.2 목록만 활성화된 경우)
                else if (levelState === 'list') {
                     // main-list-column (Lev.2)과 main-detail-column (초기 빈 상태 또는 첫 항목 상세) 모두 보임
                     // width는 CSS 기본값 (35%, 65%) 유지
                }
            }
        }


        // --- Lev.2 목록 렌더링 함수들 ---

        // 포켓몬 타입/등급 목록 렌더링 (mainListColumn에)
        function renderPokemonTypeOrGradeList(sectionType) {
            let dataList;
            let title;
            if (sectionType === 'pokemon-type') {
                const uniqueTypes = new Set();
                window.pokemonData.forEach(p => p.type.forEach(t => uniqueTypes.add(t)));
                dataList = Array.from(uniqueTypes).sort();
                title = '타입 목록';
            } else { // pokemon-grade
                const uniqueGrades = new Set();
                window.pokemonData.forEach(p => uniqueGrades.add(p.grade));
                dataList = Array.from(uniqueGrades).sort((a,b) => {
                    const gradeOrder = {'SS':3, 'S+':2, 'S':1, 'A':0};
                    return (gradeOrder[b] || 0) - (gradeOrder[a] || 0);
                });
                title = '등급 목록';
            }

            mainListColumn.innerHTML = `<h3>${title}</h3><ul id="${sectionType}-list"></ul>`;
            const listUl = document.getElementById(`${sectionType}-list`);

            dataList.forEach(item => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = item;
                link.onclick = (event) => {
                    event.preventDefault();
                    // Lev.3: 해당 타입/등급의 포켓몬 이름 목록 표시
                    renderPokemonNamesForTypeOrGrade(item, sectionType);
                    setActiveListItem(link);
                    showContentColumns('pokemon-names', { type: sectionType, filterValue: item });
                };
                listItem.appendChild(link);
                listUl.appendChild(listItem);
            });

            // 첫 번째 항목 자동 클릭 (초기 로드 시 Lev.3 포켓몬 이름 목록 + Lev.4 상세 표시)
            if (dataList.length > 0) {
                listUl.querySelector('li a').click();
            }
        }

        // 일반 아이템/룬/칩 목록 렌더링 (mainListColumn에)
        function renderGenericList(type, dataDetails) {
            let title;
            if (type === 'item') title = '아이템 목록';
            else if (type === 'rune') title = '룬 목록';
            else if (type === 'chip') title = '칩 목록';
            // TODO: 아이템/칩의 Lev.2 분류 기준(빨간색, 개구리가시 등)이 data.js에 없어 현재는 모든 이름을 나열합니다.
            // 이 부분을 명확한 분류 기준으로 변경하려면 data.js에 해당 필드를 추가해야 합니다.

            mainListColumn.innerHTML = `<h3>${title}</h3><ul id="${type}-list"></ul>`;
            const listUl = document.getElementById(`${type}-list`);

            Object.keys(dataDetails).forEach(key => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = key;
                link.onclick = (event) => {
                    event.preventDefault();
                    // Lev.3: 상세 정보 표시
                    showItemRuneChipDetail(key, type);
                    setActiveListItem(link);
                    showContentColumns('detail', { type: type, name: key });
                };
                listItem.appendChild(link);
                listUl.appendChild(listItem);
            });

            // 첫 번째 항목 자동 클릭
            if (Object.keys(dataDetails).length > 0) {
                listUl.querySelector('li a').click();
            }
        }

        // 추천 덱 분류 목록 렌더링 (mainListColumn에)
        function renderRecommendedDeckTypeList() {
            mainListColumn.innerHTML = `<h3>덱 분류</h3><ul id="recommended-decks-type-list"></ul>`;
            const listUl = document.getElementById('recommended-decks-type-list');

            const uniqueTypes = new Set();
            Object.values(window.recommendedDeckDetails).forEach(deck => {
                if (deck.type) uniqueTypes.add(deck.type);
            });
            const sortedTypes = Array.from(uniqueTypes).sort();
            sortedTypes.unshift('전체 덱'); // '전체 덱' 옵션 추가

            sortedTypes.forEach(type => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = type;
                link.onclick = (event) => {
                    event.preventDefault();
                    // Lev.3: 해당 타입의 덱 상세 표시 (현재는 첫 번째 덱)
                    showRecommendedDeckDetail(type);
                    setActiveListItem(link);
                    showContentColumns('detail', { type: 'recommended-decks', filterValue: type });
                };
                listItem.appendChild(link);
                listUl.appendChild(listItem);
            });

            if (sortedTypes.length > 0) {
                listUl.querySelector('li a').click();
            }
        }

        // 캘린더 이벤트 타입 목록 렌더링 (mainListColumn에)
        function renderCalendarTypeList() {
            mainListColumn.innerHTML = `<h3>이벤트 타입</h3><ul id="calendar-type-list"></ul>`;
            const listUl = document.getElementById('calendar-type-list');

            const uniqueTypes = new Set();
            // 요청에 따라 '랭킹전', '한정뽑기'만 표시하도록 필터링
            const desiredTypes = ['랭킹전', '한정뽑기'];
            window.calendarEvents.forEach(event => {
                if (desiredTypes.includes(event.type)) {
                    uniqueTypes.add(event.type);
                }
            });
            const sortedTypes = Array.from(uniqueTypes).sort();

            sortedTypes.forEach(type => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = type;
                link.onclick = (event) => {
                    event.preventDefault();
                    // Lev.3: 해당 타입의 이벤트 일정 표시
                    showCalendarEventsByType(type);
                    setActiveListItem(link);
                    showContentColumns('detail', { type: 'calendar', filterValue: type });
                };
                listItem.appendChild(link);
                listUl.appendChild(listItem);
            });

            if (sortedTypes.length > 0) {
                listUl.querySelector('li a').click();
            }
        }

        // 팁 & 노하우 제목 목록 렌더링 (mainListColumn에)
        function renderTipsAndKnowhowList() {
            mainListColumn.innerHTML = `<h3>글 제목</h3><ul id="tips-knowhow-list"></ul>`;
            const listUl = document.getElementById('tips-knowhow-list');

            // 요청에 따라 '육성가이드', '성급기준', '조각 활용'과 같은 명확한 제목만 필터링 필요
            // data.js에 category 필드가 있으나, 요청하신 제목과 직접 일치하지 않으므로,
            // 모든 제목을 나열하는 것으로 유지합니다. (필요시 data.js 수정 또는 여기에 필터링 로직 추가)

            window.tipsAndKnowhow.forEach(tip => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = tip.title;
                link.onclick = (event) => {
                    event.preventDefault();
                    // Lev.3: 글 내용 표시
                    showTipDetail(tip.id);
                    setActiveListItem(link);
                    showContentColumns('detail', { type: 'tips-knowhow', id: tip.id });
                };
                listItem.appendChild(link);
                listUl.appendChild(listItem);
            });

            if (window.tipsAndKnowhow.length > 0) {
                listUl.querySelector('li a').click();
            }
        }


        // --- Lev.3/Lev.4 상세 렌더링 함수들 (mainDetailColumn에) ---

        // Lev.3: 타입/등급에 따른 포켓몬 이름 목록 렌더링 (mainDetailColumn에)
        function renderPokemonNamesForTypeOrGrade(filterValue, sectionType) {
            mainDetailColumn.innerHTML = `
                <h3>${filterValue} ${sectionType === 'pokemon-type' ? '타입' : '등급'} 포켓몬</h3>
                <ul id="pokemon-filtered-list"></ul>
                <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
            `;
            const listUl = document.getElementById('pokemon-filtered-list');

            const filteredPokemons = window.pokemonData.filter(p => {
                if (sectionType === 'pokemon-type') {
                    return p.type.includes(filterValue);
                } else if (sectionType === 'pokemon-grade') {
                    return p.grade === filterValue;
                }
                return false;
            });

            if (filteredPokemons.length === 0) {
                listUl.innerHTML = `<li><p>해당 ${filterValue}에 맞는 포켓몬이 없습니다.</p></li>`;
                mainDetailColumn.innerHTML += `<p class="text-center mt-4">해당 ${filterValue}에 맞는 포켓몬 상세 정보는 없습니다.</p>`;
            } else {
                filteredPokemons.forEach(pokemon => {
                    const listItem = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = "#";
                    link.textContent = pokemon.name;
                    link.onclick = (event) => {
                        event.preventDefault();
                        // Lev.4: 포켓몬 최종 상세 렌더링 (mainDetailColumn의 내용을 교체)
                        renderPokemonFinalDetail(pokemon.id, sectionType, filterValue);
                        setActiveListItem(link); // 활성 스타일 적용
                        // showContentColumns는 renderPokemonFinalDetail 내에서 호출됩니다.
                    };
                    listItem.appendChild(link);
                    listUl.appendChild(listItem);
                });
                // 첫 번째 포켓몬 상세 정보 자동 클릭 (PC에서 Lev.3 목록이 보인 상태에서 Lev.4 상세를 대체함)
                if (listUl.querySelector('li a')) {
                    listUl.querySelector('li a').click();
                }
            }

            // PC에서는 돌아가기 버튼 숨김
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }

        // Lev.3: 아이템/룬/칩 상세 렌더링 (mainDetailColumn에)
        function showItemRuneChipDetail(name, type) {
            const detail = (type === 'item' ? window.itemDetails : type === 'rune' ? window.runeDetails : window.chipDetails)[name];

            mainDetailColumn.innerHTML = `
                <h3>${name} 정보</h3>
                <div class="detail-content">
                    <img src="${detail.imageUrl || 'https://via.placeholder.com/150/CCCCCC/FFFFFF?text=No+Image'}" alt="${name} 이미지" class="${detail.imageUrl ? '' : 'hidden'}">
                    <h4>${name}</h4>
                    <p>${detail.description.replace(/\n/g, '<br>')}</p>
                </div>
                <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
            `;
            // PC에서는 돌아가기 버튼 표시
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }

        // Lev.3: 추천 덱 상세 렌더링 (mainDetailColumn에)
        function showRecommendedDeckDetail(deckTypeFilter) {
            let decksToDisplay = [];
            if (deckTypeFilter === '전체 덱') {
                decksToDisplay = Object.values(window.recommendedDeckDetails);
            } else {
                decksToDisplay = Object.values(window.recommendedDeckDetails).filter(deck => deck.type === deckTypeFilter);
            }

            const selectedDeck = decksToDisplay.length > 0 ? decksToDisplay[0] : null;

            if (selectedDeck) {
                mainDetailColumn.innerHTML = `
                    <h3>${selectedDeck.name || "선택된 덱"}</h3>
                    <div class="detail-content">
                        <img src="${selectedDeck.imageUrl || 'https://via.placeholder.com/150/FFD700/000000?text=Deck'}" alt="${selectedDeck.name} 이미지" class="${selectedDeck.imageUrl ? '' : 'hidden'}">
                        <h4>${selectedDeck.name || "선택된 덱"}</h4>
                        <p>${selectedDeck.description.replace(/\n/g, '<br>')}</p>
                        <p><strong>구성 포켓몬:</strong> ${selectedDeck.pokemons ? selectedDeck.pokemons.join(', ') : '정보 없음'}</p>
                        <p><strong>전략:</strong> ${selectedDeck.strategy || '정보 없음'}</p>
                    </div>
                    <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
                `;
            } else {
                mainDetailColumn.innerHTML = `
                    <h3>덱 정보 없음</h3>
                    <div class="detail-content">
                        <p>선택된 덱의 정보를 찾을 수 없습니다.</p>
                    </div>
                    <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
                `;
            }
            // PC에서는 돌아가기 버튼 숨김
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }

        // Lev.3: 캘린더 이벤트 상세 렌더링 (mainDetailColumn에)
        function showCalendarEventsByType(eventType) {
            const filteredEvents = window.calendarEvents.filter(event => event.type === eventType);

            let eventsHtml = `<h3>${eventType} 이벤트 일정</h3>`;
            if (filteredEvents.length === 0) {
                eventsHtml += `<p class="text-center mt-4">${eventType} 타입의 일정이 없습니다.</p>`;
            } else {
                filteredEvents.forEach(event => {
                    eventsHtml += `
                        <div class="bg-white p-4 rounded-lg shadow-md mb-3">
                            <h4 class="text-lg font-semibold">${event.title}</h4>
                            <p class="text-sm"><strong>날짜:</strong> ${event.date} <strong>시간:</strong> ${event.time}</p>
                            <p class="text-sm">${event.description}</p>
                            ${event.imageUrl ? `<img src="${event.imageUrl}" alt="${event.title}" class="mt-2 w-full h-24 object-cover rounded-md">` : ''}
                        </div>
                    `;
                });
            }

            mainDetailColumn.innerHTML = `<div class="detail-content">${eventsHtml}</div><button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>`;
            // PC에서는 돌아가기 버튼 숨김
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }

        // Lev.3: 팁 & 노하우 상세 렌더링 (mainDetailColumn에)
        function showTipDetail(tipId) {
            const tip = window.tipsAndKnowhow.find(t => t.id === tipId);

            if (tip) {
                mainDetailColumn.innerHTML = `
                    <h3>${tip.title}</h3>
                    <div class="detail-content">
                        <h4>${tip.title}</h4>
                        <p class="text-sm text-gray-600 mb-2">작성자: <span>${tip.author}</span> | 날짜: <span>${tip.date}</span></p>
                        <div class="tip-content">${tip.content}</div>
                    </div>
                    <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
                `;
            } else {
                mainDetailColumn.innerHTML = `
                    <h3>글을 찾을 수 없습니다.</h3>
                    <div class="detail-content"><p>해당하는 팁 & 노하우 글이 존재하지 않습니다.</p></div>
                    <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">목록으로 돌아가기</button>
                `;
            }
            // PC에서는 돌아가기 버튼 숨김
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }

        // Lev.4: 포켓몬 최종 상세 렌더링 (mainDetailColumn에)
        function renderPokemonFinalDetail(pokemonId, sectionType, filterValue) {
            const pokemon = window.pokemonData.find(p => p.id === pokemonId);
            if (!pokemon) {
                mainDetailColumn.innerHTML = `
                    <h3>포켓몬 정보 없음</h3>
                    <div class="detail-content"><p>해당 포켓몬의 정보를 찾을 수 없습니다.</p></div>
                    <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">이전으로 돌아가기</button>
                `;
                return;
            }

            let skillsHtml = '';
            pokemon.skills.forEach(skill => {
                skillsHtml += `<p><strong>${skill.name}:</strong> ${skill.description}</p>`;
                if (skill.parts) {
                    skill.parts.forEach(part => {
                        skillsHtml += `<p style="margin-left: 20px;">- <strong>${part.title}:</strong> ${part.text}</p>`;
                    });
                }
            });

            mainDetailColumn.innerHTML = `
                <h3>${pokemon.name} 상세 정보</h3>
                <div class="detail-content pokemon-detail-section">
                    <img src="${pokemon.image || 'https://via.placeholder.com/150/CCCCCC/FFFFFF?text=No+Image'}" alt="${pokemon.name}" class="${pokemon.image ? '' : 'hidden'}">
                    <h4>${pokemon.name}</h4>
                    <p>${pokemon.description.replace(/\n/g, '<br>')}</p>
                    <h5 class="text-xl font-bold mb-2">스킬:</h5>
                    <div class="pokemon-skills-content">${skillsHtml}</div>
                    <p><strong>등급:</strong> ${pokemon.grade}</p>
                    <p><strong>타입:</strong> ${pokemon.type.join(', ')}</p>
                    <p><strong>성격:</strong> ${pokemon.nature.join(', ')}</p>
                    <p><strong>빌드:</strong> ${pokemon.build.join(', ')}</p>
                    <p><strong>아이템:</strong> <span class="clickable-item" onclick="openModalItemDetail('${pokemon.item}', 'item')">${pokemon.item}</span></p>
                    <p><strong>룬:</strong> <span class="clickable-item" onclick="openModalItemDetail(['${pokemon.runes.map(r => r.split(' ')[0]).join("','")}'], 'rune')">${pokemon.runes.join(', ')}</span></p>
                    <p><strong>칩:</strong> <span class="clickable-item" onclick="openModalItemDetail(['${pokemon.chips.map(c => c.split(' ')[0]).join("','")}'], 'chip')">${pokemon.chips.join(', ')}</span></p>
                    <p><strong>추천 팀:</strong> ${pokemon.team}</p>
                </div>
                <button onclick="goBack()" class="back-button bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">이전으로 돌아가기</button>
            `;
            // PC에서는 돌아가기 버튼 숨김
            if (!mediaQuery.matches) {
                mainDetailColumn.querySelector('.back-button').style.display = 'block'; // PC에서 항상 표시
            }
        }


        // --- 뒤로가기 버튼 로직 (내비게이션 스택 활용) ---

        function goBack() {
            if (navigationStack.length > 1) { // 현재 상태 (최상단) 포함 최소 2개 이상이므로 이전으로 갈 수 있음
                navigationStack.pop(); // 현재 상태 제거
                const prevState = navigationStack[navigationStack.length - 1]; // 이전 상태 가져오기

                // 이전 상태 복원 (showContentColumns를 호출하여 화면 분할을 조정하고, 해당 콘텐츠를 다시 렌더링)
                showContentColumns(prevState.level, prevState); // 스택의 이전 상태를 기반으로 화면 상태 설정

                // 이전 레벨의 콘텐츠를 다시 렌더링
                if (prevState.level === 'list') { // Lev.2 목록으로 돌아감
                    if (prevState.type === 'pokemon-type' || prevState.type === 'pokemon-grade') {
                        renderPokemonTypeOrGradeList(prevState.type);
                    } else if (prevState.type === 'item') {
                        renderGenericList('item', window.itemDetails);
                    } else if (prevState.type === 'rune') {
                        renderGenericList('rune', window.runeDetails);
                    } else if (prevState.type === 'chip') {
                        renderGenericList('chip', window.chipDetails);
                    } else if (prevState.type === 'recommended-decks') {
                        renderRecommendedDeckTypeList();
                    } else if (prevState.type === 'calendar') {
                        renderCalendarTypeList();
                    } else if (prevState.type === 'tips-knowhow') {
                        renderTipsAndKnowhowList();
                    }
                } else if (prevState.level === 'pokemon-names') { // 포켓몬 Lev.3 이름 목록으로 돌아감
                    renderPokemonNamesForTypeOrGrade(prevState.filterValue, prevState.type);
                } else if (prevState.level === 'detail') { // 일반 섹션의 Lev.3 상세로 돌아감
                    if (prevState.type === 'item') {
                         showItemRuneChipDetail(prevState.name, prevState.type);
                    } else if (prevState.type === 'rune') {
                         showItemRuneChipDetail(prevState.name, prevState.type);
                    } else if (prevState.type === 'chip') {
                         showItemRuneChipDetail(prevState.name, prevState.type);
                    } else if (prevState.type === 'recommended-decks') {
                         showRecommendedDeckDetail(prevState.filterValue);
                    } else if (prevState.type === 'calendar') {
                         showCalendarEventsByType(prevState.filterValue);
                    } else if (prevState.type === 'tips-knowhow') {
                         showTipDetail(prevState.id);
                    }
                }
                // renderPokemonFinalDetail은 goBack() 내부에서 호출되지 않음 (그 레벨에서 다시 goBack() 호출)

                // 스택에서 현재 상태가 제거되었으므로 activeListItem 초기화
                setActiveListItem(null);
            } else {
                // 스택에 더 이상 뒤로 갈 상태가 없을 때 (최초 Lev.1에서 시작)
                // 초기 공란 화면으로 돌아감
                dynamicContentSection.classList.remove('active');
                initialBlankSection.classList.add('active');

                // 사이드바 활성 스타일 초기화
                document.querySelectorAll('.sidebar ul li a').forEach(link => {
                    link.classList.remove('active');
                });
                // '포켓몬 타입'을 기본 활성화 상태로 설정
                document.querySelector('.sidebar ul li a[onclick*="showSection(\'pokemon-type\', this)"]').classList.add('active'); 

                // 광고 새로고침
                showAd();
            }
        }


        // --- 유틸리티 함수들 ---

        function getSectionTitle(sectionType) {
            const titles = {
                'pokemon-type': '포켓몬 타입 정보',
                'pokemon-grade': '포켓몬 등급 정보',
                'item': '아이템 정보',
                'rune': '룬 정보',
                'chip': '칩 정보',
                'recommended-decks': '추천 덱',
                'calendar': '이벤트 캘린더',
                'tips-knowhow': '팁 & 노하우'
            };
            return titles[sectionType] || '정보';
        }

        let activeListItem = null; // 활성 목록 항목을 추적하기 위한 전역 변수

        function setActiveListItem(linkElement) {
            if (activeListItem) {
                activeListItem.classList.remove('active');
            }
            linkElement.classList.add('active');
            activeListItem = linkElement;
        }

        // 모달 열기 (아이템/룬/칩 팝업)
        function openModalItemDetail(nameOrNames, type) {
            let dataObject;
            let titleText = '';
            let defaultImage = '';

            if (type === 'item') {
                dataObject = window.itemDetails; titleText = '아이템 정보'; defaultImage = 'https://via.placeholder.com/100/FF5733/FFFFFF?text=Item';
            } else if (type === 'rune') {
                dataObject = window.runeDetails; titleText = '룬 정보'; defaultImage = 'https://via.placeholder.com/100/33FF57/FFFFFF?text=Rune';
            } else if (type === 'chip') {
                dataObject = window.chipDetails; titleText = '칩 정보'; defaultImage = 'https://via.placeholder.com/100/3357FF/FFFFFF?text=Chip';
            } else {
                console.error("알 수 없는 모달 타입:", type); return;
            }

            const modalTitle = document.getElementById('generalModalTitle');
            const modalImage = document.getElementById('generalModalImage');
            const modalDescription = document.getElementById('generalModalDescription');
            const modal = document.getElementById('generalModal');

            modalTitle.textContent = titleText;
            modalImage.classList.add('hidden');
            modalDescription.innerHTML = '';

            let detailsHtml = '';
            const names = Array.isArray(nameOrNames) ? nameOrNames : [nameOrNames];

            if (names.length > 0) {
                names.forEach(name => {
                    const detail = dataObject[name.trim()];
                    if (detail) {
                        detailsHtml += `<h5 class="font-bold text-lg mt-3">${name.trim()}</h5>`;
                        detailsHtml += `<p>${detail.description.replace(/\n/g, '<br>')}</p>`;
                        if (detail.imageUrl && modalImage.classList.contains('hidden')) { // 첫 이미지일 경우에만 설정
                             modalImage.src = detail.imageUrl;
                             modalImage.classList.remove('hidden');
                        }
                    } else {
                        detailsHtml += `<h5 class="font-bold text-lg mt-3">${name.trim()}</h5>`;
                        detailsHtml += `<p>정보를 찾을 수 없습니다.</p>`;
                    }
                });
            } else {
                detailsHtml = '<p>선택된 항목이 없습니다.</p>';
            }

            modalDescription.innerHTML = detailsHtml;

            // 만약 이미지가 하나도 설정되지 않았다면 기본 플레이스홀더 이미지 사용
            if (modalImage.classList.contains('hidden')) {
                modalImage.src = defaultImage;
                modalImage.classList.remove('hidden');
            }

            modal.style.display = 'flex';
        }

        // 모달 닫기 함수
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }


        // --- AdSense 광고 로드 ---
        let adRetryCount = 0;
        const maxAdRetries = 5;

        function showAd() {
            const adsContainer = document.getElementById('top-ad-container');
            if (adsContainer) {
                // 기존 광고를 제거하고 새로운 광고를 요청
                adsContainer.innerHTML = `
                    <ins class="adsbygoogle"
                         style="display:block; text-align:center;"
                         data-ad-client="${adClient}"
                         data-ad-slot="${adSlot}"
                         data-ad-format="auto"
                         data-full-width-responsive="true"></ins>
                `;
                
                // Google Adsense 라이브러리가 로드되었는지 확인 후 광고 푸시
                if (typeof (adsbygoogle) !== 'undefined' && Array.isArray(window.adsbygoogle) && window.adsbygoogle.length > 0) {
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    console.log("AdSense 광고 요청 푸시 완료.");
                    adRetryCount = 0; // 성공 시 재시도 카운트 초기화
                } else if (adRetryCount < maxAdRetries) {
                    console.warn(`AdSense 라이브러리가 아직 로드되지 않았거나 배열이 비어있습니다. ${adRetryCount + 1}/${maxAdRetries} 재시도합니다.`);
                    adRetryCount++;
                    setTimeout(showAd, 500); // 0.5초 후 재시도
                } else {
                    console.error("AdSense 광고 로드 실패: 최대 재시도 횟수 초과.");
                    adRetryCount = 0; // 카운트 초기화
                }
            }
        }


        // --- 초기 로드 및 반응형 처리 ---

        // DOMContentLoaded: HTML 문서가 완전히 로드되면 실행
        document.addEventListener('DOMContentLoaded', () => {
            // 초기 화면 설정 (Lev.1 사이드바 + 우측 공란)
            initialBlankSection.classList.add('active'); // 초기 공란 섹션 활성화
            showAd(); // 초기 광고 로드

            // 미디어 쿼리 변경 감지 리스너 등록
            mediaQuery.addListener(handleMediaQueryChange);
        });

        // 미디어 쿼리 변경 감지 (PC <-> 모바일 전환 시)
        function handleMediaQueryChange(e) {
            // 초기 공란 섹션이 활성화되어 있을 경우 처리하지 않음
            if (initialBlankSection.classList.contains('active')) {
                return;
            }
            
            // 현재 활성 섹션의 컬럼들을 현재 미디어 쿼리 상태에 맞게 재정렬
            // 현재 표시 중인 레벨(currentDisplayLevel)을 기반으로 컬럼 가시성을 설정합니다.
            // 스택의 최상단 상태를 기준으로 재렌더링
            const currentState = navigationStack[navigationStack.length - 1];
            if (currentState) {
                showContentColumns(currentState.level, currentState);
            }
        }
    </script>
    <script>
        // Tailwind CSS Production Warning suppression
        window.tailwind = {
            prefix: 'tw-',
            important: true,
        };
    </script>
</body>
</html>
